<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Scroll Wall ‚Ä¢ Build v4.2</title>
<style>
  :root{
    --ink:#e9eef5; --ink-dim:#b9c2cf;
    --bg:#0a0f14; --bg2:#0e141c; --panel:#121a23;
    --accent:#ff6fa0; --accent-ink:#200914;
    --good:#ffd24d; --bad:#ff8a7a; --ok:#79d2ff;
    --ring:#2a3a4f; --ring2:#3a4f6a; --shadow:#000000aa;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;
    color:var(--ink); background:
      radial-gradient(1200px 600px at 50% -200px,#1a2230 0%,#0d1218 60%,#0a0f14 100%),
      linear-gradient(#0e141c,#0a0f14);
    background-attachment:fixed;
  }
  .wrap{max-width:820px;margin:18px auto 80px;padding:0 14px}
  header{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:8px 0 14px}
  header .ver{margin-left:auto;opacity:.7;font-weight:600}
  .btn{
    display:inline-flex;align-items:center;justify-content:center;gap:.5rem;
    padding:.9rem 1.2rem;border-radius:16px;background:linear-gradient(180deg,#182231,#111821);
    color:var(--ink); border:1px solid var(--ring); box-shadow:0 6px 20px -10px #000;
    user-select:none; -webkit-tap-highlight-color:transparent; cursor:pointer;
    transition:.2s transform,.2s background,.2s border-color,.2s opacity;
  }
  .btn:active{transform:translateY(1px)}
  .btn.primary{background:linear-gradient(180deg,#ff7cab,#ff6fa0); color:var(--accent-ink); font-weight:800}
  .btn.badge{position:relative}
  .badge-dot{position:absolute;top:-6px;right:-6px;height:12px;width:12px;background:var(--good);border-radius:50%;box-shadow:0 0 0 2px #0a0f14}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .stat{min-width:92px;text-align:center;border:1px dashed var(--ring);border-radius:16px;padding:.9rem 1.1rem;color:var(--ink-dim)}
  .toast{
    position:fixed;left:50%;bottom:20px;transform:translateX(-50%);background:#1b2431;color:#ffdede;
    border:1px solid #563549;border-radius:14px;padding:.8rem 1rem;box-shadow:0 10px 30px var(--shadow);
    max-width:90vw;z-index:60;display:none
  }
  .panel{background:linear-gradient(180deg,#111922,#0f1720);border:1px solid var(--ring);border-radius:20px;padding:16px;box-shadow:0 10px 40px #00000055}
  .grid{display:grid;gap:18px;margin-top:16px}
  .card{
    position:relative;background:linear-gradient(180deg,#121c27,#0f171f); border:1px solid var(--ring2);
    border-radius:22px; padding:14px 14px 12px; box-shadow:0 20px 60px #00000066;
    overflow:hidden; touch-action:pan-y; /* allow vertical scroll; we handle horizontal swipe */
  }
  .polaroid{
    background:#121820;border-radius:16px;padding:10px;border:1px solid #223144;
    box-shadow:0 12px 24px #00000066 inset, 0 18px 50px #00000088;
  }
  .media{
    width:100%;max-height:68vh;object-fit:cover;border-radius:12px;display:block;background:#0c131a;
  }
  .meta{display:flex;gap:10px;align-items:center;margin:10px 2px 0}
  .chip{padding:.45rem .8rem;border-radius:999px;background:#162233;border:1px solid #253549;color:#cfe4ff}
  .actions{display:flex;gap:10px;margin-left:auto}
  .like,.dislike{
    height:44px;width:58px;border-radius:14px;border:1px solid #2a3b51;display:inline-flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg,#182231,#111821); box-shadow:0 8px 28px #00000066; font-size:22px
  }
  .like{background:linear-gradient(180deg,#ffd680,#ffc54a);color:#3a2600;border-color:#6a5220}
  .dislike{background:linear-gradient(180deg,#ff9e90,#ff8576);color:#3a1010;border-color:#6a3030}
  .ghost{opacity:.55;pointer-events:none}
  /* swipe cues */
  .cue{position:absolute;top:12px;left:12px;padding:.35rem .6rem;border-radius:999px;font-weight:700;backdrop-filter:blur(6px);display:none}
  .cue.like{background:#ffd24d; color:#201400}
  .cue.dislike{background:#ff8a7a;color:#200707}
  /* Troubleshoot modal */
  dialog{border:none;background:#0e1520;padding:0;border-radius:18px;box-shadow:0 30px 90px #000}
  dialog::backdrop{background:#0008}
  .diag-body{padding:14px}
  pre{white-space:pre-wrap;max-height:55vh;overflow:auto;background:#0c121a;border:1px solid #223044;border-radius:12px;padding:12px}
  .verbar{opacity:.7;margin:0 8px}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <button id="homeBtn" class="btn">Home</button>
      <button id="likedBtn" class="btn badge">Liked ‚≠ê<span id="likedDot" class="badge-dot" style="display:none"></span></button>
      <button id="tsBtn" class="btn">Troubleshoot ü©∫</button>
      <span class="ver">NSFW enabled<span class="verbar">‚Ä¢</span>people-only<span class="verbar">‚Ä¢</span>Build v4.2</span>
    </header>

    <div class="panel row">
      <button id="newBatch" class="btn">New batch</button>
      <button id="loadMore" class="btn primary">Load more</button>
      <div id="counter" class="stat">0/0</div>
      <button id="shuffle" class="btn">Shuffle üîÄ</button>
    </div>

    <div id="list" class="grid"></div>
  </div>

  <div id="toast" class="toast"></div>

  <dialog id="diag">
    <div class="diag-body">
      <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:10px">
        <strong style="font-size:18px">Troubleshoot</strong>
        <button id="diagClose" class="btn primary" style="padding:.5rem 1rem">Close</button>
      </div>
      <pre id="logBox">Loading‚Ä¶</pre>
    </div>
  </dialog>

<script>
(() => {
  // ----------------------------
  // Config
  // ----------------------------
  const BUILD = '4.2';
  const NAMES = [
    // keep it people-only; mostly models / influencers / actors (adult-only content intended)
    "Alexis Ren","Ana de Armas","Anya Taylor-Joy","Addison Rae","Amelia Gray","Barbara Palvin","Bella Hadid","Camila Morrone",
    "Camila Cabello","Candice Swanepoel","Charli D'Amelio","Dua Lipa","Emily Ratajkowski","Emilia Clarke","Hailee Steinfeld",
    "Hailey Bieber","Jenna Ortega","Jennie Blackpink","Kendall Jenner","Kylie Jenner","Kaia Gerber","Lily-Rose Depp","Madelyn Cline",
    "Madison Beer","Megan Fox","Mia Khalifa","Nina Dobrev","Rita Ora","Sabrina Carpenter","Sydney Sweeney","Taylor Hill","Zendaya",
    "Sommer Ray","Alexandra Daddario","Salma Hayek","Gal Gadot","Sofia Vergara","Doja Cat","Kali Uchis","Iggy Azalea","Lais Ribeiro",
    "Bruna Marquezine","Sophie Turner","Gigi Hadid","Dixie D'Amelio","Alessandra Ambrosio","Rosie Huntington-Whiteley","Karlie Kloss",
    "Irina Shayk","Olivia Rodrigo","Lana Del Rey","Ariana Grande","Maitreyi Ramakrishnan","Rachel Cook","Madi Edwards","Lexi Rivera",
    "Pia Wurtzbach","Hannah Palmer","Violet Myers","Sophie Mudd","Paige Spiranac","Natalie Roush","Hana Bunny","Lindsey Pelas",
    "Lyna Perez","Abigail Ratchford","Charly Jordan","Tana Mongeau","Lauren Summer","Jailyne Ojeda"
  ];
  const REDGIFS_HOST = 'https://api.redgifs.com';
  const FETCH_TIMEOUT = 12000;         // ms for each HTTP call
  const PER_PULL = 6;                   // try to fetch up to this many items per "Load more"
  const MAX_POOL = 60;                  // cap in-memory pool

  // ----------------------------
  // State
  // ----------------------------
  let token = null;
  let tokenAt = 0;
  let pool = [];   // queued media (objects with {title, mp4, poster, label})
  let shown = 0;
  let likes = JSON.parse(localStorage.getItem('likes.v1')||'[]');
  let cooldownUntil = 0;
  const logLines = [];

  // ----------------------------
  // Helpers
  // ----------------------------
  const $ = sel => document.querySelector(sel);
  const on = (el,ev,fn) => el.addEventListener(ev,fn,{passive:true});
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const now = () => Date.now();
  function log(msg){
    const stamp = new Date().toLocaleTimeString();
    const line = `[${stamp}] ${msg}`;
    logLines.push(line);
    if(logLines.length>200) logLines.shift();
    // also show small toasts for notable issues
    if (/429|token|auth|failed/i.test(msg)) toast(msg.includes('429')?'Rate limited ‚Äî pausing briefly':'‚ö†Ô∏è '+msg, 1800);
    updateDiag();
  }
  function toast(text, ms=1600){
    const t = $('#toast');
    t.textContent = text;
    t.style.display='block';
    clearTimeout(t._h);
    t._h=setTimeout(()=>t.style.display='none', ms);
  }
  function setBusy(btn, busy=true){
    btn.classList.toggle('ghost',busy);
    btn.disabled = busy;
  }
  function updateCounter(){ $('#counter').textContent = `${shown}/${pool.length}`; }
  function updateLikedDot(){ $('#likedDot').style.display = likes.length? 'block':'none'; }

  // ----------------------------
  // Token & fetch with timeout
  // ----------------------------
  async function ensureToken(force=false){
    if(!force && token && (now()-tokenAt)<(4*60*1000)) return token; // 4 min
    try{
      const res = await fetch(`${REDGIFS_HOST}/v2/auth/temporary`, {method:'POST', headers:{'Content-Type':'application/json'}});
      if(!res.ok){ log(`Auth error ${res.status}`); throw new Error('auth '+res.status); }
      const data = await res.json();
      token = data?.access_token || data?.token || null;
      tokenAt = now();
      log('Got new RedGifs token');
      return token;
    }catch(e){
      log('Token fetch failed: '+e.message);
      throw e;
    }
  }
  async function xfetch(url, opt={}){
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort(), opt.timeout||FETCH_TIMEOUT);
    try{
      const res = await fetch(url, { ...opt, signal: ctrl.signal });
      return res;
    } finally { clearTimeout(t); }
  }

  // ----------------------------
  // Search RedGifs for a person name
  // ----------------------------
  function nameVariants(name){
    // a few query variations to improve hit rate
    const base = name.replace(/[^\w\s']/g,' ').replace(/\s+/g,' ').trim();
    const parts = [base, `${base} model`, `${base} instagram`, `${base} bikini`];
    // randomize order each time
    return parts.sort(()=>Math.random()-.5);
  }
  async function searchOne(name){
    const tok = await ensureToken();
    const headers = { Authorization: 'Bearer '+tok };
    const variants = nameVariants(name);
    for (let i=0;i<variants.length;i++){
      const q = encodeURIComponent(variants[i]);
      const url = `${REDGIFS_HOST}/v2/gifs/search?search_text=${q}&order=trending&count=30`;
      try{
        const res = await xfetch(url,{headers});
        if(res.status===429){ cooldownUntil = now()+ (1000 + Math.random()*1500); log(`429 from RedGifs (query "${variants[i]}")`); await sleep(400); continue; }
        if(res.status===401 || res.status===403){ log('Token rejected ‚Äî refreshing'); await ensureToken(true); i--; continue; }
        if(!res.ok){ log(`Search ${variants[i]}: ${res.status}`); continue; }
        const data = await res.json();
        const arr = (data?.gifs)||[];
        const mapped = arr.map(g => {
          const mp4 = g?.urls?.hd || g?.urls?.sd || '';
          const poster = g?.urls?.poster || g?.urls?.thumbnail || '';
          return mp4 ? { title: g?.title || name, mp4, poster, label: name } : null;
        }).filter(Boolean);
        if(mapped.length){ return mapped; }
      }catch(e){
        if(e.name==='AbortError'){ log('Timeout on '+variants[i]); }
        else log('Fetch error: '+e.message);
      }
    }
    log(`${name}: Load failed`);
    return [];
  }

  // ----------------------------
  // Pool management
  // ----------------------------
  async function fillPool(amount=PER_PULL){
    if(now()<cooldownUntil){ const wait= cooldownUntil-now(); log(`Cooling down ${Math.ceil(wait)}ms`); await sleep(wait); }
    const need = Math.max(0, amount - (pool.length - shown));
    if(need<=0) return;
    const names = [...NAMES].sort(()=>Math.random()-.5).slice(0, need*2); // extra to absorb misses
    const batches = [];
    for (const nm of names){
      batches.push(searchOne(nm));
      if (batches.length>=3){ // limit parallelism
        const packs = await Promise.all(batches.splice(0));
        for (const p of packs) pushToPool(p);
      }
    }
    if (batches.length){
      const packs = await Promise.all(batches);
      for (const p of packs) pushToPool(p);
    }
  }
  function pushToPool(items){
    if(!items?.length) return;
    pool.push(...items);
    // cap
    if(pool.length>MAX_POOL) pool = pool.slice(-MAX_POOL);
    updateCounter();
  }

  // ----------------------------
  // UI rendering
  // ----------------------------
  function makeCard(item){
    const card = document.createElement('div'); card.className='card';
    const cueLike = Object.assign(document.createElement('div'),{className:'cue like',textContent:'LIKE'});
    const cueDis = Object.assign(document.createElement('div'),{className:'cue dislike',textContent:'NOPE'});
    const frame = document.createElement('div'); frame.className='polaroid';
    const v = document.createElement('video');
    v.className='media';
    v.muted = true; v.playsInline = true; v.autoplay = true; v.loop = true; v.controls = false;
    v.src = item.mp4; if(item.poster) v.poster = item.poster;
    v.addEventListener('error', () => { log('Video error '+item.label); });
    v.addEventListener('play', () => { v.classList.remove('ghost'); });

    frame.appendChild(v);
    const meta = document.createElement('div'); meta.className='meta';
    const chip = Object.assign(document.createElement('div'),{className:'chip',textContent:item.label});
    const actions = Object.assign(document.createElement('div'),{className:'actions'});
    const likeBtn = Object.assign(document.createElement('button'),{className:'like',innerHTML:'‚≠ê'});
    const disBtn  = Object.assign(document.createElement('button'),{className:'dislike',innerHTML:'üëé'});
    actions.append(likeBtn,disBtn); meta.append(chip,actions);

    card.append(cueLike,cueDis,frame,meta);

    // Buttons
    likeBtn.addEventListener('click', ()=> doLike(card,item));
    disBtn.addEventListener('click',  ()=> doDismiss(card));

    // Swipe (horizontal) without hijacking page scroll
    let sx=0, sy=0, dragging=false;
    card.addEventListener('touchstart', e=>{ if(e.touches.length!==1) return; sx=e.touches[0].clientX; sy=e.touches[0].clientY; dragging=true; });
    card.addEventListener('touchmove', e=>{
      if(!dragging) return;
      const dx = e.touches[0].clientX - sx;
      const dy = e.touches[0].clientY - sy;
      if(Math.abs(dx)>Math.abs(dy)*1.5){
        e.preventDefault(); // horizontal swipe wins
        card.style.transform = `translateX(${dx}px) rotate(${dx*0.03}deg)`;
        cueLike.style.display = dx>30 ? 'inline-flex':'none';
        cueDis.style.display  = dx<-30 ? 'inline-flex':'none';
        card.style.opacity = 1-Math.min(Math.abs(dx)/600, .35);
      }
    }, {passive:false});
    card.addEventListener('touchend', e=>{
      if(!dragging) return; dragging=false;
      const dx = (e.changedTouches[0].clientX - sx);
      cueLike.style.display = cueDis.style.display = 'none';
      if(dx>120){ doLike(card,item,true); return; }
      if(dx<-120){ doDismiss(card,true); return; }
      card.style.transition='transform .2s ease,opacity .2s ease';
      card.style.transform='none'; card.style.opacity='1';
      setTimeout(()=>{card.style.transition=''},220);
    });

    return card;
  }

  function doLike(card,item,swiped=false){
    likes.unshift({t:now(), label:item.label, mp4:item.mp4, poster:item.poster||'', build:BUILD});
    localStorage.setItem('likes.v1', JSON.stringify(likes.slice(0,500)));
    updateLikedDot();
    animateCard(card, true, swiped);
  }
  function doDismiss(card,swiped=false){
    animateCard(card, false, swiped);
  }
  function animateCard(card, liked, swiped){
    const dir = liked? 1 : -1;
    card.style.transition='transform .22s ease,opacity .22s ease';
    card.style.transform=`translateX(${dir*160}px) rotate(${dir*6}deg)`;
    card.style.opacity='0';
    setTimeout(()=>{ card.remove(); }, 230);
  }

  async function renderMore(count=3){
    await fillPool(count);
    const list = $('#list');
    let added = 0;
    while (shown < pool.length && added < count){
      const item = pool[shown++];
      list.appendChild( makeCard(item) );
      added++;
    }
    if(added===0) toast('Nothing else in this batch ‚Äî tap New batch.');
    updateCounter();
  }

  function resetBatch(){
    shown=0; pool=[]; updateCounter(); $('#list').innerHTML='';
  }

  // ----------------------------
  // Troubleshoot modal
  // ----------------------------
  function updateDiag(){
    const tokAge = token? Math.round((now()-tokenAt)/1000)+'s':'none';
    const cd = cooldownUntil>now()? (cooldownUntil-now())+'ms' : 'none';
    const lines = logLines.slice(-15).join('\n');
    $('#logBox').textContent =
`Online: true
Token age: ${tokAge}
Cooldown: ${cd}
Pool size: ${pool.length}, shown: ${shown}, likes: ${likes.length}
Last lines:
${lines || '(none)'}
`;
  }

  // ----------------------------
  // Init + events
  // ----------------------------
  updateLikedDot(); updateCounter(); updateDiag();

  on($('#diagClose'),'click',()=>$('#diag').close());
  on($('#tsBtn'),'click',()=>{ updateDiag(); $('#diag').showModal(); });

  on($('#likedBtn'),'click',()=>{
    // lightweight liked page: render likes as cards with only video/poster
    const list = $('#list'); list.innerHTML='';
    if(!likes.length){ toast('No likes yet'); return; }
    likes.slice(0,80).forEach(l=>{
      const card = document.createElement('div'); card.className='card';
      const p = document.createElement('div'); p.className='polaroid';
      const v = document.createElement('video'); v.className='media'; v.muted=true; v.playsInline=true; v.loop=true; v.autoplay=true; v.src=l.mp4; if(l.poster) v.poster=l.poster;
      p.appendChild(v);
      const meta = document.createElement('div'); meta.className='meta';
      const chip = Object.assign(document.createElement('div'),{className:'chip',textContent:l.label||'Liked'});
      const actions = Object.assign(document.createElement('div'),{className:'actions'});
      const del = Object.assign(document.createElement('button'),{className:'dislike',innerHTML:'üóëÔ∏è'});
      del.addEventListener('click',()=>{
        likes = likes.filter(x=>x!==l); localStorage.setItem('likes.v1',JSON.stringify(likes)); card.remove(); updateLikedDot();
      });
      actions.append(del); meta.append(chip,actions);
      card.append(p,meta); list.append(card);
    });
  });

  on($('#homeBtn'),'click',()=>{ $('#list').innerHTML=''; shown=0; updateCounter(); });

  on($('#newBatch'),'click', async ()=>{
    setBusy($('#newBatch'),true); setBusy($('#loadMore'),true);
    resetBatch();
    try{
      await ensureToken(true);
      await fillPool(6);
      await renderMore(3);
    } finally {
      setBusy($('#newBatch'),false); setBusy($('#loadMore'),false);
    }
  });

  on($('#loadMore'),'click', async ()=>{
    setBusy($('#loadMore'),true);
    try{
      await renderMore(3);
    } finally { setBusy($('#loadMore'),false); }
  });

  on($('#shuffle'),'click', async ()=>{
    pool = pool.slice(shown); // keep only remaining
    // random shuffle
    for(let i=pool.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [pool[i],pool[j]]=[pool[j],pool[i]]; }
    shown = 0; const cur = $('#list'); cur.innerHTML=''; updateCounter();
    toast('Shuffled batch', 900);
    await renderMore(3);
  });

  // Kick-off: acquire token but don‚Äôt block the UI
  ensureToken().catch(()=>{});
})();
</script>
</body>
</html>